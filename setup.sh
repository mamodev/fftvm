#!/bin/bash
set -e 

declare -A FLAGS_DESC
declare -A FLAGS_DEF
declare -A FLAGS

FLAGS_DESC["tvm-branch"]="Specify the TVM branch to use"
FLAGS_DEF["tvm-branch"]="main"
FLAGS_DESC["tvm-force-rebuild"]="Force rebuild of TVM"
FLAGS_DEF["tvm-force-rebuild"]="false"
FLAGS_DESC["tvm-use-llvm"]="Enable LLVM support in TVM"
FLAGS_DEF["tvm-use-llvm"]="true"
FLAGS_DESC["ff-branch"]="Specify the FastFlow branch to use"
FLAGS_DEF["ff-branch"]="master"

for key in "${!FLAGS_DEF[@]}"; do
    FLAGS[$key]="${FLAGS_DEF[$key]}"
done

PARSE_STR="--long "
for key in "${!FLAGS_DEF[@]}"; do
    if [ "${FLAGS_DEF[$key]}" != "true" ] && [ "${FLAGS_DEF[$key]}" != "false" ]; then
        key="$key:"
    fi
    PARSE_STR+="$key,"
done

OPTS=$(getopt --options '' $PARSE_STR -- "$@")
eval set -- "$OPTS"

# while true; do
while [ $# -gt 0 ]; do
    if [ "$1" = "--" ]; then
        shift
        break
    fi

    flag="$1"
    flag_name="${flag/--/}"
    if [[ -v FLAGS_DESC[$flag_name] ]]; then
        if [ "${FLAGS_DEF[$flag_name]}" = "true" ] || [ "${FLAGS_DEF[$flag_name]}" = "false" ]; then
            FLAGS[$flag_name]="true"
            shift
        else
            FLAGS[$flag_name]="$2"
            shift 2
        fi
    else 
        echo "Invalid option: $flag"
        exit 1
    fi
done


# ==============================

SCRIPT_DIR=$(pwd)
mkdir -p "$SCRIPT_DIR/3rdparty"

TVM_REPO="https://github.com/apache/tvm.git"
TVM_FOLDER="$SCRIPT_DIR/3rdparty/tvm"

FF_REPO="https://github.com/fastflow/fastflow.git"
FF_FOLDER="$SCRIPT_DIR/3rdparty/fastflow"

#Dependency versions
CMAKE_REQUIRED_VERSION="3.24.0"
LLVM_REQUIRED_VERSION="15.0.0"
PYTHON_REQUIRED_VERSION="3.8.0"

REBUILD_TVM="${FLAGS["tvm-force-rebuild"]}"

# ==============================
# Check for required commands
# ==============================

if ! command -v git &> /dev/null; then
    echo "git could not be found, please install git."
    exit
fi

if ! command -v python3 -m venv &> /dev/null; then
    echo "python3 venv module could not be found, please install python3-venv."
    exit
else
    PYTHON_VERSION=$(python3 --version | awk '{print $2}')
    if [ "$(printf '%s\n' "$PYTHON_REQUIRED_VERSION" "$PYTHON_VERSION" | sort -V | head -n1)" != "$PYTHON_REQUIRED_VERSION" ]; then
        echo "Python version $PYTHON_VERSION found, but version >= $PYTHON_REQUIRED_VERSION is required. Please update Python."
        exit
    fi
fi

# check cmake >= 3.24.0
if ! command -v cmake &> /dev/null; then
    echo "cmake could not be found, please install cmake >= $CMAKE_REQUIRED_VERSION."
    exit
else
    CMAKE_VERSION=$(cmake --version | head -n1 | awk '{print $3}')
    if [ "$(printf '%s\n' "$CMAKE_REQUIRED_VERSION" "$CMAKE_VERSION" | sort -V | head -n1)" != "$CMAKE_REQUIRED_VERSION" ]; then
        echo "cmake version $CMAKE_VERSION found, but version >= $CMAKE_REQUIRED_VERSION is required. Please update cmake."
        exit
    fi
fi

if ! command -v llvm-config &> /dev/null; then
    echo "llvm-config could not be found, please install LLVM >= $LLVM_REQUIRED_VERSION."
    exit
else
    LLVM_VERSION=$(llvm-config --version)
    if [ "$(printf '%s\n' "$LLVM_REQUIRED_VERSION" "$LLVM_VERSION" | sort -V | head -n1)" != "$LLVM_REQUIRED_VERSION" ]; then
        echo "LLVM version $LLVM_VERSION found, but version >= $LLVM_REQUIRED_VERSION is required. Please update LLVM."
        exit
    fi
fi

# Create a .env file 
echo "# This file is auto-generated by setup.sh" > .env

# ==============================
# Setup Python virtual environment
# ==============================
cd "$SCRIPT_DIR"
echo "source .venv/bin/activate" >> .env

if [ ! -d ".venv" ]; then
    python3 -m venv .venv
    cp ./requirements.txt .venv/
fi

source .venv/bin/activate

if [ "x$(cat .venv/requirements.txt | md5sum)" != "x$(cat requirements.txt | md5sum)" ]; then
    echo "Updating Python dependencies..."
    cp ./requirements.txt .venv/
    pip install --upgrade pip
    pip install -r .venv/requirements.txt
else
    echo "Python dependencies are up to date."
fi

# ==============================
# Ensure TVM
# ==============================

cd "$SCRIPT_DIR"
if [ ! -d "$TVM_FOLDER" ]; then
    git clone --depth 1 --recursive --branch "${FLAGS["tvm-branch"]}" "$TVM_REPO" "$TVM_FOLDER"
    REBUILD_TVM=true
fi

cd "$TVM_FOLDER"
git fetch origin "${FLAGS["tvm-branch"]}"
LOCAL=$(git rev-parse HEAD)
REMOTE=$(git rev-parse origin/"${FLAGS["tvm-branch"]}")
if [ "$LOCAL" != "$REMOTE" ]; then
    echo "The local TVM repository is out of date, dowload the latest version and rebuild TVM? (y/n)"
    read -r answer
    if [ "$answer" = "y" ]; then
        git pull origin "${FLAGS["tvm-branch"]}"
        rm -rf build #ensure no cache problems doing a clean build
        REBUILD_TVM=true
    else
        REBUILD_TVM=false
        echo "Skipping TVM rebuild"
    fi
else
    echo "TVM is up to date."
fi

cd "$TVM_FOLDER"

if [ "$REBUILD_TVM" = true ]; then
    echo "Building TVM..."

    mkdir -p build
    cd build

    cp ../cmake/config.cmake .

    if [ "${FLAGS["tvm-use-llvm"]}" = "true" ]; then
        sed -i 's/set(USE_LLVM OFF)/set(USE_LLVM ON)/' config.cmake
    else
        sed -i 's/set(USE_LLVM ON)/set(USE_LLVM OFF)/' config.cmake
    fi

    cmake ..
    make -j$(nproc)

    echo "TVM build complete."
else
    echo "Skipping TVM rebuild."
fi


if ! python3 -c "import tvm_ffi" &> /dev/null || [ "$REBUILD_TVM" = true ]; then
    echo "Building and installing tvm-ffi..."
    cd "$TVM_FOLDER/3rdparty/tvm-ffi"
    pip uninstall tvm-ffi -y || true
    pip install .
    echo "tvm-ffi installation complete."
else
    echo "tvm-ffi is already installed."
fi


cd "$SCRIPT_DIR"

echo "export TVM_HOME=$TVM_FOLDER" >> .env

# set up tvm-ffi
echo "export C_INCLUDE_PATH=\$TVM_HOME/3rdparty/tvm-ffi/include:\$C_INCLUDE_PATH" >> .env
echo "export C_INCLUDE_PATH=\$TVM_HOME/3rdparty/tvm-ffi/3rdparty/dlpack/include:\$C_INCLUDE_PATH" >> .env

echo "export CPLUS_INCLUDE_PATH=\$TVM_HOME/3rdparty/tvm-ffi/include:\$CPLUS_INCLUDE_PATH" >> .env
echo "export CPLUS_INCLUDE_PATH=\$TVM_HOME/3rdparty/tvm-ffi/3rdparty/dlpack/include:\$CPLUS_INCLUDE_PATH" >> .env

# tvm-ffi static and shared libraries
echo "export LIBRARY_PATH=\$TVM_HOME/build/lib:\$LIBRARY_PATH" >> .env
echo "export LD_LIBRARY_PATH=\$TVM_HOME/build/lib:\$LD_LIBRARY_PATH" >> .env

echo "export PYTHONPATH=\$TVM_HOME/python:\$TVM_HOME/ffi/python:\$PYTHONPATH" >> .env

# set up tvm
echo "export C_INCLUDE_PATH=\$TVM_HOME/include:\$C_INCLUDE_PATH" >> .env
echo "export CPLUS_INCLUDE_PATH=\$TVM_HOME/include:\$CPLUS_INCLUDE_PATH" >> .env
# tvm .so => $TVM_HOME/build/libtvm_runtime.so
echo "export LIBRARY_PATH=\$TVM_HOME/build:\$LIBRARY_PATH" >> .env
echo "export LD_LIBRARY_PATH=\$TVM_HOME/build:\$LD_LIBRARY_PATH" >> .env

# include paths for 3rdparty tvm dependencies

# dmlc-core
echo "export C_INCLUDE_PATH=\$TVM_HOME/3rdparty/dmlc-core/include:\$C_INCLUDE_PATH" >> .env
echo "export CPLUS_INCLUDE_PATH=\$TVM_HOME/3rdparty/dmlc-core/include:\$CPLUS_INCLUDE_PATH" >> .env


# =============================
# TVM python requirements
# =============================

if [ ! -f "$SCRIPT_DIR/requirements.tvm.txt" ] || [ "$REBUILD_TVM" = true ]; then
    cd "$TVM_FOLDER"/python
    python3 gen_requirements.py
    mv requirements/core.txt $SCRIPT_DIR/requirements.tvm.txt
    rm -r requirements

    echo "tvm requirements generated at $SCRIPT_DIR/requirements.tvm.txt"
    echo "Installing tvm requirements in the virtual environment..."
    pip install -r "$SCRIPT_DIR/requirements.tvm.txt"
    echo "tvm requirements installation complete."
else
    echo "tvm core requirements are up to date."
fi

# =============================
# FastFlow setup
# =============================
cd "$SCRIPT_DIR/3rdparty"

FF_CHANGED=false

if [ ! -d "$FF_FOLDER" ]; then
    echo "Cloning FastFlow repository..."
    git clone --depth 1 --branch "${FLAGS["ff-branch"]}" "$FF_REPO" "$FF_FOLDER"
    FF_CHANGED=true
else
    cd "$FF_FOLDER"
    git fetch origin "${FLAGS["ff-branch"]}"
    LOCAL=$(git rev-parse HEAD)
    REMOTE=$(git rev-parse origin/"${FLAGS["ff-branch"]}")
    if [ "$LOCAL" != "$REMOTE" ]; then
        echo "The local FastFlow repository is out of date, dowload the latest version? (y/n)"
        read -r answer
        if [ "$answer" = "y" ]; then
            FF_CHANGED=true
            git pull origin "${FLAGS["ff-branch"]}"
        else
            echo "Skipping FastFlow update"
        fi
    else
        echo "FastFlow is up to date."
    fi
fi

if [ "$FF_CHANGED" = true ]; then
    echo "Setting up FastFlow mapping string..."
    cd "$FF_FOLDER/ff"
    ./mapping_string.sh
fi

echo "export C_INCLUDE_PATH=$FF_FOLDER:\$C_INCLUDE_PATH" >> "$SCRIPT_DIR/.env"
echo "export CPLUS_INCLUDE_PATH=$FF_FOLDER:\$CPLUS_INCLUDE_PATH" >> "$SCRIPT_DIR/.env"


# =============================
# Finalize
# =============================

cd "$SCRIPT_DIR"
deactivate
echo "Setup complete."
echo "You can activate the environment by running 'source .env'."